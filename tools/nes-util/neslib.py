"""A library for miscellaneous NES (Nintendo Entertainment System) stuff."""

import ineslib

PALETTE = {
    # key=index, value=(R, G, B); source: FCEUX (fceux.pal)
    0x00: (0x74, 0x74, 0x74),
    0x01: (0x24, 0x18, 0x8c),
    0x02: (0x00, 0x00, 0xa8),
    0x03: (0x44, 0x00, 0x9c),
    0x04: (0x8c, 0x00, 0x74),
    0x05: (0xa8, 0x00, 0x10),
    0x06: (0xa4, 0x00, 0x00),
    0x07: (0x7c, 0x08, 0x00),
    0x08: (0x40, 0x2c, 0x00),
    0x09: (0x00, 0x44, 0x00),
    0x0a: (0x00, 0x50, 0x00),
    0x0b: (0x00, 0x3c, 0x14),
    0x0c: (0x18, 0x3c, 0x5c),
    0x0d: (0x00, 0x00, 0x00),
    0x0e: (0x00, 0x00, 0x00),
    0x0f: (0x00, 0x00, 0x00),
    0x10: (0xbc, 0xbc, 0xbc),
    0x11: (0x00, 0x70, 0xec),
    0x12: (0x20, 0x38, 0xec),
    0x13: (0x80, 0x00, 0xf0),
    0x14: (0xbc, 0x00, 0xbc),
    0x15: (0xe4, 0x00, 0x58),
    0x16: (0xd8, 0x28, 0x00),
    0x17: (0xc8, 0x4c, 0x0c),
    0x18: (0x88, 0x70, 0x00),
    0x19: (0x00, 0x94, 0x00),
    0x1a: (0x00, 0xa8, 0x00),
    0x1b: (0x00, 0x90, 0x38),
    0x1c: (0x00, 0x80, 0x88),
    0x1d: (0x00, 0x00, 0x00),
    0x1e: (0x00, 0x00, 0x00),
    0x1f: (0x00, 0x00, 0x00),
    0x20: (0xfc, 0xfc, 0xfc),
    0x21: (0x3c, 0xbc, 0xfc),
    0x22: (0x5c, 0x94, 0xfc),
    0x23: (0xcc, 0x88, 0xfc),
    0x24: (0xf4, 0x78, 0xfc),
    0x25: (0xfc, 0x74, 0xb4),
    0x26: (0xfc, 0x74, 0x60),
    0x27: (0xfc, 0x98, 0x38),
    0x28: (0xf0, 0xbc, 0x3c),
    0x29: (0x80, 0xd0, 0x10),
    0x2a: (0x4c, 0xdc, 0x48),
    0x2b: (0x58, 0xf8, 0x98),
    0x2c: (0x00, 0xe8, 0xd8),
    0x2d: (0x78, 0x78, 0x78),
    0x2e: (0x00, 0x00, 0x00),
    0x2f: (0x00, 0x00, 0x00),
    0x30: (0xfc, 0xfc, 0xfc),
    0x31: (0xa8, 0xe4, 0xfc),
    0x32: (0xc4, 0xd4, 0xfc),
    0x33: (0xd4, 0xc8, 0xfc),
    0x34: (0xfc, 0xc4, 0xfc),
    0x35: (0xfc, 0xc4, 0xd8),
    0x36: (0xfc, 0xbc, 0xb0),
    0x37: (0xfc, 0xd8, 0xa8),
    0x38: (0xfc, 0xe4, 0xa0),
    0x39: (0xe0, 0xfc, 0xa0),
    0x3a: (0xa8, 0xf0, 0xbc),
    0x3b: (0xb0, 0xfc, 0xcc),
    0x3c: (0x9c, 0xfc, 0xf0),
    0x3d: (0xc4, 0xc4, 0xc4),
    0x3e: (0x00, 0x00, 0x00),
    0x3f: (0x00, 0x00, 0x00),
}

def PRG_address_to_CPU_addresses(fileInfo, PRGAddr):
    """Generate CPU ROM addresses (0x8000-0xffff) from the PRG ROM address.
    fileInfo: from ineslib.parse_iNES_header()
    PRGAddr: PRG ROM address"""

    PRGBankSize = ineslib.get_PRG_bank_size(fileInfo)
    offset = PRGAddr & (PRGBankSize - 1)  # address within each bank

    for origin in range(0x8000, 0x10000, PRGBankSize):
        yield origin | offset

def CPU_address_to_PRG_addresses(handle, CPUAddr, compareValue=None):
    """Generate PRG ROM addresses that may correspond to the CPU address.
    handle: handle of a valid iNES file (.nes)
    CPUAddr: CPU ROM address (0x8000-0xffff)
    compareValue: 0x00-0xff or None"""

    fileInfo = ineslib.parse_iNES_header(handle)
    PRGBankSize = ineslib.get_PRG_bank_size(fileInfo)
    offset = CPUAddr & (PRGBankSize - 1)  # address within each bank

    PRGAddrRange = range(offset, fileInfo["PRGSize"], PRGBankSize)

    if compareValue is None:
        for PRGAddr in PRGAddrRange:
            yield PRGAddr
    else:
        for PRGAddr in PRGAddrRange:
            handle.seek(16 + fileInfo["trainerSize"] + PRGAddr)
            if handle.read(1)[0] == compareValue:
                yield PRGAddr

def decode_tile_slice(LSBs, MSBs):
    """Decode 8*1 pixels of one tile (planar to interleaved).
    LSBs: the least significant bits (8-bit int)
    MSBs: the most significant bits (8-bit int)
    return: pixels (iterable, 8 2-bit big-endian ints)"""

    pixels = 8 * [0]
    for i in range(7, -1, -1):
        pixels[i] = (LSBs & 1) | ((MSBs & 1) << 1)
        LSBs >>= 1
        MSBs >>= 1

    return pixels

def decode_tile(data):
    """Decode an NES tile (planar to interleaved).
    data: 16 bytes
    return: pixels as 64 2-bit big-endian integers"""

    decodedData = []
    for bitplanes in zip(data[0:8], data[8:16]):  # LSBs, MSBs
        decodedData.extend(decode_tile_slice(*bitplanes))
    return tuple(decodedData)

def encode_tile_slice(tileSlice):
    """Encode 8*1 pixels of one tile (interleaved to planar).
    tileSlice: pixels (8 2-bit big-endian ints)
    return: (8-bit int least_significant_bits, 8-bit int most_significant_bits)"""

    LSBs = MSBs = 0
    for pixel in tileSlice:
        LSBs = (LSBs << 1) | (pixel & 1)
        MSBs = (MSBs << 1) | (pixel >> 1)

    return (LSBs, MSBs)

